<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Even - A super concise theme for Hugo</title>
    <link>http://localhost:1313/tags/java/</link>
    <description>Recent content in Java on Even - A super concise theme for Hugo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 03 Dec 2018 21:54:05 +0800</lastBuildDate>
    
	<atom:link href="http://localhost:1313/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>利用126邮箱在阿里云中发送SSL/TSL加密邮件</title>
      <link>http://localhost:1313/post/java-concurrency/send-ssl-mail-with-126-in-aliyun/</link>
      <pubDate>Mon, 03 Dec 2018 21:54:05 +0800</pubDate>
      
      <guid>http://localhost:1313/post/java-concurrency/send-ssl-mail-with-126-in-aliyun/</guid>
      <description>&lt;p&gt;由于工作原因需要在阿里云中部署一个Web系统，该系统会调用邮箱服务器定时给相关人员发送通知邮件,在测试邮箱配置时，发现始终无法正确发送邮件，而之前在研发环境和测试环境都能正常工作。网上查找之后，发现是阿里云出于安全原因默认禁止了25端口的出方向访问，需要进行&lt;strong&gt;&lt;a href=&#34;https://help.aliyun.com/knowledge_detail/56130.html?spm=5176.10695662.1996646101.searchclickresult.51d3cd65xV8EFf&#34; title=&#34;25端口解封申请&#34;&gt;25端口解封申请&lt;/a&gt;&lt;/strong&gt;，按照说明提交相应的申请后没想到不到一个小时就提醒申请未通过，同时提示使用465端口来发送加密邮件。基于此，本文简要说明如何使用126邮箱通过465端口在阿里云中发送邮件。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在不重新编译的情况下直接修改Java Class文件中的内容</title>
      <link>http://localhost:1313/post/java-concurrency/modify-java-class-file-content-directly/</link>
      <pubDate>Sat, 12 Aug 2017 18:09:53 +0800</pubDate>
      
      <guid>http://localhost:1313/post/java-concurrency/modify-java-class-file-content-directly/</guid>
      <description>&lt;p&gt;Java程序实际上执行的是Java文件编译后的Class文件，这是任何一个Java开发人员都了解的基本知识。若Java程序执行的结果不符合要求，通常的解决方法是先修改Java文件，重新编译成Class文件后再次执行。但有时候我们不能直接修改Java文件（如只有包含class文件的jar包），此时我们就只能直接修改Class文件，本文将展示在基于不同的需求通过可视化工具和Javassist库来直接对Class文件进行修改的方法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java中==和equals的区别，equals和hashCode的区别</title>
      <link>http://localhost:1313/post/java-concurrency/vs-equalsequals-vs-hashcode%E7%9A%84/</link>
      <pubDate>Sat, 05 Aug 2017 00:10:11 +0800</pubDate>
      
      <guid>http://localhost:1313/post/java-concurrency/vs-equalsequals-vs-hashcode%E7%9A%84/</guid>
      <description>Java中==和equals的区别，equals和hashCode的区别 [image:60177432-F479-464C-BE21-7B8F66A4F197-12665-00005FA8FAAF5FE4/1.png] 原 2015年07月21日 17:01:56 天天 阅读数 35525 版权声明：本文为博主原创文章</description>
    </item>
    
    <item>
      <title>[译] Java Volatile 关键字详解</title>
      <link>http://localhost:1313/post/java-concurrency/java-volatile-keyword/</link>
      <pubDate>Mon, 07 Mar 2016 18:03:18 +0800</pubDate>
      
      <guid>http://localhost:1313/post/java-concurrency/java-volatile-keyword/</guid>
      <description>&lt;p&gt;本文翻译自 &lt;strong&gt;&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/volatile.html&#34;&gt;Java Volatile Keyword&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Java关键字&lt;code&gt;volatile&lt;/code&gt;用于将一个Java变量标记为 &lt;em&gt;在主内中存储&lt;/em&gt; ，更准确的解释为：每次读取一个 &lt;em&gt;volatile&lt;/em&gt; 变量时将从电脑的主内存中读取而不是从CPU缓存中读取，每次对一个 &lt;em&gt;volatile&lt;/em&gt; 变量进行写操作时，将会写入到主内存中而不是写入到CPU缓存中。&lt;/p&gt;

&lt;p&gt;事实上，从Java5之后，&lt;em&gt;volatile&lt;/em&gt; 关键字不仅仅可以用来确保 &lt;em&gt;volatile&lt;/em&gt; 变量是写入到主内存和从主内存读取数据，我会在下面的章节进行详细的介绍：&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>